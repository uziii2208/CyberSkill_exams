# Terraform Configuration for Dockerized Node.js Application

## Objective
This Terraform configuration provisions infrastructure on AWS to deploy a Dockerized Node.js application. It includes creating an EC2 instance, installing Docker, running the application, and enabling observability.

## Features
- Deploys the Node.js application as a Docker container.
- Provisions an AWS EC2 instance for hosting the application.
- Configures security groups to allow necessary traffic (SSH and app port).
- Includes Terraform variables for easy customization.
- Logs and metrics are available for observability.

---

## Prerequisites
Before starting, ensure you have the following installed and configured:
1. **AWS CLI**: [AWS CLI Installation Guide](https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html)
2. **Terraform**: [Terraform Installation Guide](https://www.terraform.io/downloads)
3. **Docker**: Installed on the AWS EC2 instance (automatically configured by the `main.tf`).
4. **SSH Key**: An SSH key pair for accessing the EC2 instance. Update the path in the `main.tf` accordingly.

---

## Directory Structure

```
Lab_Assignment_Final/
├── photos/
├── scripts/
│   ├── logs/
│   │   ├── access.log
│   │   ├── analyzed_log.log
│   │   ├── cpu_mem_usage.log
│   │   ├── daily_logs.gz
│   │   ├── script.log
│   └── helloworld.py
├── terraform/
│   ├── main.tf
│   ├── variables.tf
│   ├── outputs.tf
│   └── README.md
```

---

## Terraform Configuration Files

### `main.tf`
This file contains the core Terraform configuration, which:
- Defines the AWS provider and region.
- Creates an EC2 instance for the application.
- Installs Docker and runs the Node.js application inside a container.
- Configures an AWS security group for SSH and app traffic.

### `variables.tf`
Contains configurable variables for the infrastructure. Adjust these values to match your requirements.

### `outputs.tf`
Defines the output values, such as the public IP of the EC2 instance, for easy access post-deployment.

---

## How to Use

### Step 1: Clone the Repository
Clone this repository to your local machine:
```bash
git clone https://github.com/<your-repo>.git
cd Lab_Assignment_Final/terraform
```

### Step 2: Initialize Terraform
Run the following command to initialize Terraform and download the necessary providers:
```bash
terraform init
```

### Step 3: Validate the Configuration
Ensure the Terraform configuration is valid:
```bash
terraform validate
```

### Step 4: Apply the Configuration
Provision the infrastructure by applying the configuration:
```bash
terraform apply
```
- When prompted, type `yes` to confirm.
- After completion, Terraform will display the public IP of the EC2 instance.

### Step 5: Access the Application
Access the application via the public IP of the EC2 instance on port `8000`:
```bash
curl http://<EC2_PUBLIC_IP>:8000/
curl http://<EC2_PUBLIC_IP>:8000/getInfo
```
- **Endpoints**:
  - `/`: Returns a description of the lab.
  - `/getInfo`: Returns personal information.

---

## Configurable Variables

The `variables.tf` file allows you to customize the setup:

| Variable              | Description                               | Default Value  |
|-----------------------|-------------------------------------------|----------------|
| `aws_region`          | AWS region for the infrastructure         | `us-east-1`    |
| `instance_type`       | EC2 instance type                         | `t2.micro`     |
| `app_port`            | Port for the application                  | `8000`         |
| `ssh_key_path`        | Path to your SSH public key               | `~/.ssh/id_rsa.pub` |

To override these values, create a `terraform.tfvars` file or pass variables directly when applying:
```bash
terraform apply -var="app_port=8080"
```

---

## Outputs

After running `terraform apply`, the following outputs will be displayed:

| Output                | Description                               |
|-----------------------|-------------------------------------------|
| `instance_public_ip`  | Public IP of the EC2 instance             |

Use the `instance_public_ip` to access the application.

---

## Logs and Observability

Logs generated by the application are stored in the `scripts/logs` folder:
- `access.log`: HTTP request logs.
- `analyzed_log.log`: Processed logs for analysis.
- `cpu_mem_usage.log`: Resource usage logs.
- `script.log`: General script execution logs.

---

## Cleanup

To destroy the infrastructure and clean up all resources:
```bash
terraform destroy
```
- Confirm by typing `yes` when prompted.

---

## Troubleshooting

### Docker Issues
- Ensure the Docker daemon is running on the EC2 instance.
- Check the Docker installation script in the `user_data` section of `main.tf`.

### SSH Access
- If SSH access is not working, verify the key pair and security group configurations.

### Port Conflicts
- Ensure the application port (`8000` by default) is not already in use.
- Update the `app_port` variable if needed.

---

## Notes

- This setup is designed for educational purposes. Adjust security settings (e.g., restrict CIDR blocks) for production deployments.
- The Terraform configuration automates most tasks, but you can modify it further to suit your needs.

---

## Conclusion

This lab demonstrates using Terraform to provision AWS infrastructure for a Dockerized Node.js application. It automates the entire process, making it efficient and reproducible.

---

## This lab is a complete Terraform configuration for Dockerized Node.js Application
